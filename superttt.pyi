# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import numpy
import numpy.typing

class Checkpoint:
    def get_odds(self) -> list[float]:
        ...

    def __str__(self) -> str:
        ...


class Game:
    r"""
    Game class
    
    # Methods:
    * get_available_moves() - Returns a vector containing the cells that are `valid` in the current state.
    * make_move(input, player_id_authentication)
    """
    def __new__(cls,id:int): ...
    def get_available_moves(self) -> list[int]:
        ...

    def make_move(self, input:int, player_id_authentication:int) -> bool:
        r"""
        Make a move. This does nothing else.
        
        
        ## Args
        * `input` - the cell that the current player makes a move in.
        * `player_id_authentication` - the id of the player that is making the move. This should be one of: {1, 2}
        """
        ...

    def get_winner(self) -> int:
        r"""
        Returns the id of the winner of the game.
        
        If it is equal to 0, then the game ended in a draw.
        """
        ...

    def make_checkpoint(self) -> Checkpoint:
        r"""
        Create a checkpoint. This can be saved somewhere and loaded in at a later point in time.
        """
        ...

    def load_checkpoint(self, checkpoint:Checkpoint) -> None:
        r"""
        Load in a checkpoint from a PyCheckpoint object.
        
        ## Args
        * `checkpoint` - checkpoint to load in.
        """
        ...

    def make_state(self) -> State:
        r"""
        Create a `PyState`-object.
        This object is a simple representation of the current game.
        """
        ...

    def __str__(self) -> str:
        r"""
        Python __str__ method
        """
        ...


class Player:
    def __new__(cls,id:int): ...
    def make_move(self, game:Game) -> None:
        r"""
        Make a move with the current player.
        The default implementation is naive (makes a random move).
        
        Override this method to have your custom heuristic.
        """
        ...

    def increment_wins(self) -> None:
        r"""
        Increment the number of wins for a player by one.
        """
        ...

    def get_wins(self) -> int:
        r"""
        Get the total number of wins for a player.
        """
        ...


class State:
    r"""
    Represent a Pythonlike state. The current board, next player, and all possible moves.
    Uses Numpy arrays when possible.
    
    Important note:
    * board - this attribute is a 1D-array. The first 9 elements represent the first field (upper left), the next 9 the second field (upper center) and so on
    ```text
    Layout:
     0  1  2        9  10  11       18  19  20
     3  4  5       12  13  14       21  22  23
     6  7  8       15  16  17       24  25  26
     
    27  28  29     36  37  38       45  46  47
    30  31  32     39  40  41       48  49  50
    33  34  35     42  43  44       51  52  53
    
    54  55  56     63  64  65       72  73  74
    57  58  59     66  67  68       75  76  77
    60  61  62     69  70  71       78  79  80
    ```
    """
    board: numpy.typing.NDArray[numpy.int8]
    player_id: int
    possible_moves: numpy.typing.NDArray[numpy.int8]
    def __str__(self) -> str:
        ...

    def to_checkpoint(self) -> Checkpoint:
        r"""
        Coerces a pystate into a checkpoint. 
        
        This can be used to load in a checkpoint. 
        Method is rather expensive.
        
        Note:
        The reason why checkpoints and states are not the same is a design choice. 
        We wanted the state to be as minimal as possible.
        """
        ...


def play_game(player1:Player,player2:Player,game:Game) -> list[State]:
    r"""
    Play one game between two player objects.
    Delegates to overridden make_move method if it exists.
    
    Todo: add caching for speeding up perhaps?
    """
    ...

def play_multiple_games(player1:Player,player2:Player,number_of_games:int) -> list[State]:
    r"""
    Play multiple games in a single-threaded environment
    """
    ...

